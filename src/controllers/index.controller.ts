import { Request, Response } from "express";
import prisma from "../db/connection";
import { 
  processDocument, 
  updateContentTsvector, 
  calculateBM25, 
  getCachedResults, 
  cacheSearchResults 
} from "../indexer/indexer"; 
import { BM25Score } from "../indexer/ranker";

export const addDocument = async (req: Request, res: Response): Promise<void> => {
  try {
    const { document, url, crawlDepth, ipAddress } = req.body;

    if (!document || typeof document !== "string" || !url || typeof url !== "string" || !crawlDepth || typeof crawlDepth !== "number" || !ipAddress || typeof ipAddress !== "string") {
       res.status(400).json({ error: "Invalid request. Required fields: 'document' (string), 'url' (string), 'crawlDepth' (number), 'ipAddress' (string)." });
    }

    // Generate or fetch docId (if you're storing documents in crawledDocument or another table)
    const newDoc = await prisma.crawledDocument.create({
      data: { url, crawlDepth, ipAddress, content: document }
    });
    const id = newDoc.id; //autogenerated id

    const tokens = await processDocument(document, id);  // Now we get tokens from the function
    const docLength = tokens.length;

    await prisma.documentMetadata.upsert({
      where: { docId: id },
      update: { length: docLength },
      create: { docId: id, length: docLength },
    });

    // Add tokens to inverted index
    for (const token of tokens) {
      await prisma.invertedIndex.upsert({
        where: { token_docId: { token, docId: id } },
        update: { termFreq: { increment: 1 } },
        create: { token, docId: id, termFreq: 1 },
      });
    }

    // Update tsvector for full-text search
    await updateContentTsvector(document, id);

    res.status(201).json({ message: "Document added successfully to the index." });
  } catch (error) {
    console.error("Error adding document:", error);
    res.status(500).json({ error: "Failed to add document to the index." });
  }
};

// Update an existing document
export const updateDocument = async (req: Request, res: Response) => {
  try {
    const { document, id } = req.body;

    if (!document || typeof document !== "string" || !id || typeof id !== "number") {
      return res.status(400).json({ error: "Invalid request. 'document' must be a string and 'id' must be a number." });
    }

    // Process the document and get tokens
    const tokens = await processDocument(document, id);  // Now we get tokens from the function
    const docLength = tokens.length;

    // Upsert document metadata
    await prisma.documentMetadata.upsert({
      where: { docId: id },
      update: { length: docLength },
      create: { docId: id, length: docLength },
    });

    // Remove old tokens from inverted index for this document
    await prisma.invertedIndex.deleteMany({ where: { docId: id } });

    // Add new tokens to inverted index
    for (const token of tokens) {
      await prisma.invertedIndex.upsert({
        where: { token_docId: { token, docId: id } },
        update: { termFreq: { increment: 1 } },
        create: { token, docId: id, termFreq: 1 },
      });
    }

    // Update tsvector for full-text search
    await updateContentTsvector(document, id);

    return res.status(200).json({ message: "Document updated successfully." });
  } catch (error) {
    console.error("Error updating document:", error);
    return res.status(500).json({ error: "Failed to update document." });
  }
};

// Delete a document
export const deleteDocument = async (req: Request, res: Response) => {
  try {
    const { id } = req.body;

    if (!id || typeof id !== "number") {
      return res.status(400).json({ error: "Invalid request. 'id' must be a number." });
    }

    await prisma.invertedIndex.deleteMany({ where: { docId: id } });
    await prisma.documentMetadata.delete({ where: { docId: id } });
    await prisma.crawledDocument.delete({ where: { id } });

    return res.status(200).json({ message: "Document deleted successfully." });
  } catch (error) {
    console.error("Error deleting document:", error);
    return res.status(500).json({ error: "Failed to delete document." });
  }
};

export const searchDocuments = async (req: Request, res: Response) => {
  try {
    const { query } = req.body;

    if (!query || typeof query !== "string") {
      return res.status(400).json({ error: "Invalid request. 'query' must be a string." });
    }

    // Check if results are cached
    const cachedResults = await getCachedResults(query);
    if (cachedResults) {
      return res.status(200).json({ results: cachedResults });
    }

    const tokens = await processDocument(query, 0); // Assuming 0 or another appropriate id for search queries
    const resultScores: { [docId: number]: number } = {};

    // Calculate BM25 scores for each document that contains the query tokens
    for (const token of tokens) {
      const invertedIndexData = await prisma.invertedIndex.findMany({
        where: { token },
      });

      for (const entry of invertedIndexData) {
        const docId = entry.docId;
        const score = await BM25Score(query, docId);
        resultScores[docId] = (resultScores[docId] || 0) + score;
      }
      

    }
    
    // Sort results by score
    const sortedResults = Object.entries(resultScores)
      .sort((a, b) => b[1] - a[1])
      .map(([docId]) => Number(docId));

    // Cache the results
    await cacheSearchResults(query, sortedResults);

    return res.status(200).json({ results: sortedResults });
  } catch (error) {
    console.error("Error searching documents:", error);
    return res.status(500).json({ error: "Failed to search documents." });
  }
};
